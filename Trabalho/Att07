using System;
using System.Collections.Generic;

public class Lista
{
    private List<int> items;

    public Lista()
    {
        items = new List<int>();
    }

    public Lista(IEnumerable<int> initialItems)
    {
        items = new List<int>(initialItems);
    }

    public void Append(int item) => items.Add(item);
    public void Prepend(int item) => items.Insert(0, item);
    public void Insert(int index, int item) => items.Insert(index, item);
    public void Remove(int item) => items.Remove(item);
    public void RemoveAt(int index) => items.RemoveAt(index);
    public bool Contains(int item) => items.Contains(item);
    public int IndexOf(int item) => items.IndexOf(item);
    public void Clear() => items.Clear();

    public int First => items.Count > 0 ? items[0] : throw new InvalidOperationException("Lista vazia.");
    public int Last => items.Count > 0 ? items[items.Count - 1] : throw new InvalidOperationException("Lista vazia.");
    public int Count => items.Count;

    public int GetElementAt(int index) => items[index];

    public override string ToString() => string.Join(", ", items);
}

public class ListaEncadeada
{
    private class Node
    {
        public int Data;
        public Node Next;

        public Node(int data)
        {
            Data = data;
            Next = null;
        }
    }

    private Node head;

    public ListaEncadeada() => head = null;

    public ListaEncadeada(IEnumerable<int> initialItems)
    {
        head = null;
        foreach (var item in initialItems)
            Append(item);
    }

    public void Append(int item)
    {
        if (head == null)
        {
            head = new Node(item);
        }
        else
        {
            Node current = head;
            while (current.Next != null)
                current = current.Next;
            current.Next = new Node(item);
        }
    }

    public void Prepend(int item)
    {
        Node newNode = new Node(item);
        newNode.Next = head;
        head = newNode;
    }

    public void Insert(int index, int item)
    {
        if (index == 0)
        {
            Prepend(item);
            return;
        }

        Node current = head;
        for (int i = 0; i < index - 1 && current != null; i++)
            current = current.Next;

        if (current == null) throw new IndexOutOfRangeException();

        Node newNode = new Node(item);
        newNode.Next = current.Next;
        current.Next = newNode;
    }

    public void Remove(int item)
    {
        if (head == null) return;

        if (head.Data == item)
        {
            head = head.Next;
            return;
        }

        Node current = head;
        while (current.Next != null && current.Next.Data != item)
            current = current.Next;

        if (current.Next != null)
            current.Next = current.Next.Next;
    }

    public void RemoveAt(int index)
    {
        if (head == null) throw new IndexOutOfRangeException();

        if (index == 0)
        {
            head = head.Next;
            return;
        }

        Node current = head;
        for (int i = 0; i < index - 1 && current != null; i++)
            current = current.Next;

        if (current == null || current.Next == null) throw new IndexOutOfRangeException();

        current.Next = current.Next.Next;
    }

    public bool Contains(int item)
    {
        Node current = head;
        while (current != null)
        {
            if (current.Data == item) return true;
            current = current.Next;
        }
        return false;
    }

    public int IndexOf(int item)
    {
        Node current = head;
        int index = 0;
        while (current != null)
        {
            if (current.Data == item) return index;
            current = current.Next;
            index++;
        }
        return -1;
    }

    public void Clear() => head = null;

    public int First => head?.Data ?? throw new InvalidOperationException("Lista vazia.");
    public int Last
    {
        get
        {
            if (head == null) throw new InvalidOperationException("Lista vazia.");

            Node current = head;
            while (current.Next != null)
                current = current.Next;
            return current.Data;
        }
    }

    public int Count
    {
        get
        {
            int count = 0;
            Node current = head;
            while (current != null)
            {
                count++;
                current = current.Next;
            }
            return count;
        }
    }

    public int GetElementAt(int index)
    {
        Node current = head;
        for (int i = 0; i < index && current != null; i++)
            current = current.Next;

        if (current == null) throw new IndexOutOfRangeException();
        return current.Data;
    }

    public override string ToString()
    {
        Node current = head;
        var result = "";
        while (current != null)
        {
            result += current.Data + " ";
            current = current.Next;
        }
        return result.Trim();
    }
}

public class HashMap
{
    private Dictionary<int, string> map;

    public HashMap() => map = new Dictionary<int, string>();

    public HashMap(Dictionary<int, string> initialItems)
    {
        map = new Dictionary<int, string>(initialItems);
    }

    public void Put(int key, string value) => map[key] = value;
    public bool ContainsKey(int key) => map.ContainsKey(key);
    public bool ContainsValue(string value) => map.ContainsValue(value);
    public void Remove(int key) => map.Remove(key);
    public void Clear() => map.Clear();

    public string GetByKey(int key) => map.ContainsKey(key) ? map[key] : throw new KeyNotFoundException();

    public string First => map.Count > 0 ? map.Values.GetEnumerator().Current : throw new InvalidOperationException("Map vazio.");
    public string Last => map.Count > 0 ? new List<string>(map.Values)[map.Count - 1] : throw new InvalidOperationException("Map vazio.");
    public int Count => map.Count;

    public override string ToString() => string.Join(", ", map.Select(kvp => $"{kvp.Key}: {kvp.Value}"));
}

public class Fila
{
    private Queue<int> queue;

    public Fila() => queue = new Queue<int>();

    public Fila(IEnumerable<int> initialItems) => queue = new Queue<int>(initialItems);

    public void Enqueue(int item) => queue.Enqueue(item);
    public int Dequeue() => queue.Dequeue();
    public bool Contains(int item) => queue.Contains(item);
    public void Clear() => queue.Clear();

    public int First => queue.Count > 0 ? queue.Peek() : throw new InvalidOperationException("Fila vazia.");
    public int Last => queue.Count > 0 ? queue.ToArray()[queue.Count - 1] : throw new InvalidOperationException("Fila vazia.");
    public int Count => queue.Count;

    public override string ToString() => string.Join(", ", queue);
}
